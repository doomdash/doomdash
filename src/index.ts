import { app, BrowserWindow, ipcMain } from "electron";
import log from "electron-log/main";
import extract from "extract-zip";
import * as fs from "fs";
import * as https from "https";
import * as os from "os";
import * as path from "path";
import { FileDownloader, getAppBundlePath } from "./main/FileDownloader";

log.initialize();
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
	app.quit();
}

// Function to handle file downloading
const handleDownload = (
	url: string,
	dest: string,
	mainWindow: BrowserWindow,
): Promise<void> => {
	return new Promise((resolve, reject) => {
		const file = fs.createWriteStream(dest);
		let downloadedSize = 0;
		let totalSize = 0;

		const request = https.get(url, (response) => {
			// Handle redirects
			if (response.statusCode === 301 || response.statusCode === 302) {
				const redirectUrl = response.headers.location;
				if (redirectUrl) {
					file.destroy();
					// Recursively call handleDownload with the redirect URL
					handleDownload(redirectUrl, dest, mainWindow)
						.then(resolve)
						.catch(reject);
					return;
				}
			}

			// Check for successful response
			if (response.statusCode !== 200) {
				file.destroy();
				fs.unlink(dest, () => {}); // Delete the file async
				reject(
					new Error(
						`Failed to download file: ${response.statusCode} ${response.statusMessage}`,
					),
				);
				return;
			}

			totalSize = parseInt(response.headers["content-length"] as string, 10);

			// Pipe response directly to file
			response.pipe(file);

			response.on("data", (chunk) => {
				downloadedSize += chunk.length;

				// Report progress to renderer
				if (totalSize) {
					const progress = Math.round((downloadedSize / totalSize) * 100);
					mainWindow.webContents.send("download-progress", progress);
				}
			});

			file.on("finish", () => {
				file.close();
				resolve();
			});

			response.on("error", (err) => {
				file.destroy();
				fs.unlink(dest, () => {}); // Delete the file async
				reject(err);
			});

			file.on("error", (err) => {
				response.destroy();
				reject(err);
			});
		});

		request.on("error", (err) => {
			file.destroy();
			fs.unlink(dest, () => {}); // Delete the file async
			reject(err);
		});
	});
};

// Function to register file downloader
const registerFileDownloader = (mainWindow: BrowserWindow) => {
	ipcMain.handle(
		"download-source-port",
		async (_event, sourcePortName: string) => {
			try {
				// Detect operating system
				const platform = os.platform();
				let downloadUrl = "";

				// Set download URL based on OS and source port
				switch (sourcePortName) {
					case "uzdoom":
						if (platform === "win32") {
							downloadUrl =
								"https://github.com/UZDoom/UZDoom/releases/download/4.14.3/Windows-UZDoom-4.14.3.zip";
						} else if (platform === "darwin") {
							downloadUrl =
								"https://github.com/UZDoom/UZDoom/releases/download/4.14.3/macOS-UZDoom-4.14.3.zip";
						} else {
							// For Linux, we'll use the Windows version as a placeholder
							downloadUrl =
								"https://github.com/UZDoom/UZDoom/releases/download/4.14.3/Windows-UZDoom-4.14.3.zip";
						}
						break;
					default:
						throw new Error(`Unsupported source port: ${sourcePortName}`);
				}

				// Create destination directory
				const destDir = path.join(
					app.getPath("userData"),
					"source-ports",
					sourcePortName,
				);
				if (!fs.existsSync(destDir)) {
					fs.mkdirSync(destDir, { recursive: true });
				}

				// Set destination file path
				const fileName = `uzdoom-${platform}.zip`;
				const destPath = path.join(destDir, fileName);

				// Download file
				await handleDownload(downloadUrl, destPath, mainWindow);

				// Unzip the archive
				const unzipDir = path.join(destDir, "extracted");
				await extract(destPath, { dir: unzipDir });

				// Delete the archive
				fs.unlinkSync(destPath);

				// Log the final path
				console.log(`Source port extracted to: ${destDir}`);

				// Return the parent directory instead of the extracted subdirectory
				return { success: true, path: destDir };
			} catch (error) {
				console.error("Download failed:", error);
				return { success: false, error: (error as Error).message };
			}
		},
	);
};

let mainWindow: BrowserWindow;
const createWindow = (): void => {
	// Create the browser window.
	mainWindow = new BrowserWindow({
		height: 640,
		width: 1024,
		webPreferences: {
			preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
		},
	});

	// and load the index.html of the app.
	mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

	// Register file downloader
	registerFileDownloader(mainWindow);

	// Open the DevTools.
	// mainWindow.webContents.openDevTools();
};
const systemOs = process.platform;
let uzdoomUrl: string;
let uzdoomPath: string;

switch (systemOs) {
	case "darwin": {
		uzdoomUrl =
			"https://github.com/UZDoom/UZDoom/releases/download/4.14.3/macOS-UZDoom-4.14.3.zip";
		uzdoomPath = path.join(
			app.getPath("desktop"),
			"doomdash-data/uzdoom.app/Contents/MacOS/uzdoom",
		);
		break;
	}
	case "win32": {
		uzdoomUrl =
			"https://github.com/UZDoom/UZDoom/releases/download/4.14.3/Windows-UZDoom-4.14.3.zip";
		uzdoomPath = path.join(app.getPath("desktop"), "doomdash-data/uzdoom.exe");
		break;
	}
}

app.whenReady().then(async () => {
	createWindow();
	console.log("path.dirname", path.dirname(app.getPath("exe")));
	console.log("getPath", app.getPath("exe"));
	console.log("bundlePath", getAppBundlePath());
	const downloader = new FileDownloader(mainWindow);

	await downloader.download({
		url: uzdoomUrl,
	});
	await downloader.download({
		url: "https://github.com/freedoom/freedoom/releases/download/v0.13.0/freedoom-0.13.0.zip",
	});
	log.info(`uzdoomPath: ${uzdoomPath}`);
	log.info(
		`iwad path: ${path.join(
			app.getPath("desktop"),
			"doomdash-data/freedoom-0.13.0/freedoom1.wad",
		)}`,
	);
	try {
		execUzdoom(
			uzdoomPath,
			path.join(
				app.getPath("desktop"),
				"doomdash-data/freedoom-0.13.0/freedoom1.wad",
			),
		);
	} catch (err) {
		log.error(`error execUdoom: ${err.message}`);
	}
});

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
// app.on('ready', createWindow);

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on("window-all-closed", () => {
	if (process.platform !== "darwin") {
		app.quit();
	}
});

app.on("activate", () => {
	// On OS X it's common to re-create a window in the app when the
	// dock icon is clicked and there are no other windows open.
	if (BrowserWindow.getAllWindows().length === 0) {
		createWindow();
	}
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.

import { ChildProcess, spawn } from "child_process";

/**
 * Executes the uzdoom program with a specified WAD file.
 * @param uzdoomPath The full path to the uzdoom executable (e.g., /path/to/UZDoom).
 * @param wadFilePath The full path to the WAD file to load (e.g., /path/to/doom.wad).
 * @returns A promise that resolves when uzdoom exits successfully, or rejects on error.
 */
export function execUzdoom(
	uzdoomPath: string,
	wadFilePath: string,
): Promise<void> {
	// Arguments to pass to the uzdoom executable
	// The '-iwad' argument tells the Doom source port which IWAD (initial WAD) to load.
	const args: string[] = ["-iwad", wadFilePath];
	console.log(`${uzdoomPath}${args}`);

	console.log(`Executing: ${uzdoomPath} ${args.join(" ")}`);
	log.debug(`Executing: ${uzdoomPath} ${args.join(" ")}`);

	return new Promise((resolve, reject) => {
		// 1. Start the external process
		const uzdoomProcess: ChildProcess = spawn(uzdoomPath, args, {
			// Detach the process from the current console/window (useful in Electron)
			detached: true,
			// Ensures the process is executable
			stdio: "ignore",
		});

		// 2. Handle Process Errors (e.g., uzdoomPath not found or not executable)
		uzdoomProcess.on("error", (err: Error) => {
			reject(new Error(`Failed to start uzdoom process: ${err.message}`));
		});

		// 3. Handle Process Exit
		uzdoomProcess.on("close", (code: number | null) => {
			if (code === 0) {
				// Exit code 0 is typically success
				resolve();
			} else {
				// Non-zero exit code indicates an error within uzdoom
				reject(new Error(`uzdoom process exited with code ${code}`));
			}
		});

		// IMPORTANT: Unref the process so the Node.js application can exit
		// even if uzdoom is still running (like a separate game window).
		uzdoomProcess.unref();

		// Resolve immediately here if you don't want to wait for the game to close.
		// If you want to wait for the game to close, keep the resolve inside the 'close' event.
		// resolve();
	});
}
